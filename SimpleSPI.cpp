#include "SimpleSPI.h"
#include "utils/twi.h"
#include <math.h>


/*
 *	MISO (Master In Slave Out) - The Slave line for sending data to the master,
 *	MOSI (Master Out Slave In) - The Master line for sending data to the peripherals,
 *	SCK (Serial Clock) - The clock pulses which synchronize data transmission generated by the master
 *
 *
 *	SS (Slave Select) - the pin on each device that the master can use to enable and disable specific devices.
 *	
 *
 *
 *
 *
 *
 *
*/



SimpleSPIClass spi;
uint8_t SimpleSPIClass::initialized = 0;
uint8_t SimpleSPIClass::interruptMode = 0;
uint8_t SimpleSPIClass::interruptMask = 0;
uint8_t SimpleSPIClass::interruptSave = 0;



int SimpleSPIClass::initialize()
{
	// Set SS to high so a connected chip will be "deselected" by default
	uint8_t port = digitalPinToPort(SS);
	uint8_t bit = digitalPinToBitMask(SS);
	volatile uint8_t* reg = portModeRegister(port);

	// if the SS pin is not already configured as an output
	// then set it high (to enable the internal pull-up resistor)
	if (!(*reg & bit)) {
		digitalWrite(SS, HIGH);
	}

	// When the SS pin is set as OUTPUT, it can be used as
	// a general purpose output port (it doesn't influence
	// SPI operations).
	pinMode(10, OUTPUT);

	// Warning: if the SS pin ever becomes a LOW INPUT then SPI
	// automatically switches to Slave, so the data direction of
	// the SS pin MUST be kept as OUTPUT.
	SPCR |= _BV(MSTR);
	SPCR |= _BV(SPE);

	// Set direction register for SCK and MOSI pin.
	// MISO pin automatically overrides to INPUT.
	// By doing this AFTER enabling SPI, we avoid accidentally
	// clocking in a single bit since the lines go directly
	// from "input" to SPI control.
	// http://code.google.com/p/arduino/issues/detail?id=888
	pinMode(SCK, OUTPUT);

	// MOSI digital 11
	pinMode(MOSI, OUTPUT);
	

}



int SimpleSPIClass::begin()
{

	uint8_t sreg = SREG;
	noInterrupts();
	
	if (!initialized)
	{
		initialize();
	}

	initialized++; // reference count
	SREG = sreg;

	useSPIHS = false;

	

	// Attach interrrupt
	if (writeRegister(INT_PIN_CFG, INT_PULSE_50US) < 0) {
		return -12;
	}

	if (writeRegister(INT_ENABLE, INT_RAW_RDY_EN) < 0) { // set to data ready
		return -2;
	}

	/*

	// set AK8963 to Power Down
	if (writeAK8963Register(AK8963_CNTL1, AK8963_PWR_DOWN) < 0) {
		return -11;
	}

	// check the WHO AM I byte, expected value is 0x71 (decimal 113) or 0x73 (decimal 115)
	if ((whoAmI() != 113) && (whoAmI() != 115)) {
		return 0;
	}

	// set AK8963 to Power Down
	writeAK8963Register(AK8963_CNTL1, AK8963_PWR_DOWN);

	*/

	// reset the MPU9250
	writeRegister(PWR_MGMNT_1, PWR_RESET);

	// wait for MPU-9250 to come back up
	delay(5);

	// reset the AK8963
	writeAK8963Register(AK8963_CNTL2, AK8963_RESET);

	// select clock source to gyro
	if (writeRegister(PWR_MGMNT_1, CLOCK_SEL_PLL) < 0) {
		return -4;
	}

	// enable accelerometer and gyro
	if (writeRegister(PWR_MGMNT_2, SEN_ENABLE) < 0) {
		return -6;
	}

	// expected value is 0x48 (decimal 72)
	if (whoAmIAK8963() != 72) {
		return -2;
	}

	// set AK8963 to Power Down
	if (writeAK8963Register(AK8963_CNTL1, AK8963_PWR_DOWN) < 0) {
		return -4;
	}


	// set accelerometer to low power mode
	//writeRegister(PWR_MGMNT_1, 0x09);


	delay(500); // long wait between AK8963 mode changes  

	// set AK8963 to FUSE ROM access
	if (writeAK8963Register(AK8963_CNTL1, AK8963_FUSE_ROM) < 0) {
		return -16;
	}

	// set AK8963 to Power Down
	if (writeAK8963Register(AK8963_CNTL1, AK8963_PWR_DOWN) < 0) {
		return -17;
	}
	delay(100); // long wait between AK8963 mode changes  
	// set AK8963 to 16 bit resolution, 100 Hz update rate
	if (writeAK8963Register(AK8963_CNTL1, AK8963_CNT_MEAS2) < 0) {
		return -18;
	}

	// set accel scale (default = 16g)
	//writeRegister(ACCEL_CONFIG, ACCEL_FS_SEL_8G);

	// Set gravitational constant
	setG();

	// Set sample rate in Hz - important for gyro - magnetometer will be 100Hz for any sample rate at or above 100Hz
	setSampleRate(sampleRate);

	setGyroDrift();

	return 1;

}






/* reads the most current data from MPU9250 and stores in buffer */
int SimpleSPIClass::readSensor() {

	// grab the data from the MPU9250
	if (readRegisters(ACCEL_OUT, 21, buffer) < 0) {
		return -1;
	}

	// combine into 16 bit values
	_ax = (((int16_t)buffer[0]) << 8) | buffer[1];
	_ay= (((int16_t)buffer[2]) << 8) | buffer[3];
	_az= (((int16_t)buffer[4]) << 8) | buffer[5];
	//_tcounts = (((int16_t)buffer[6]) << 8) | buffer[7];
	_gx = (((int16_t)buffer[8]) << 8) | buffer[9];
	_gy = (((int16_t)buffer[10]) << 8) | buffer[11];
	_gz = (((int16_t)buffer[12]) << 8) | buffer[13];
	_hx = (((int16_t)buffer[15]) << 8) | buffer[14];
	_hy = (((int16_t)buffer[17]) << 8) | buffer[16];
	_hz = (((int16_t)buffer[19]) << 8) | buffer[18];

	// transform and convert to float values
	xAng += ((float)_gx / 500) - xAngDrift;

	//_t = ((((float)_tcounts) - _tempOffset) / _tempScale) + _tempOffset;

	return 0;
}


// Should get the drift and adjust the angle by that every time we update it or every couple of times we update it
// based on the average gravity and magnetic 
// field felt by the sensor over the previous period of time
float SimpleSPIClass::returnVar()
{

	readSensor();
	
	return _hx;

}

void SimpleSPIClass::setG()
{

	int count = 0;
	double magnitude = 0;

	while (count < 500)
	{
		readSensor();

		float x = (float)_ax;
		float y = (float)_ay;
		float z = (float)_az;

		magnitude += sqrt(x * x + y * y + z * z);

		count++;

	}

	magnitude /= count;

	G = magnitude;

}

void SimpleSPIClass::setSampleRate(int sampleRate)
{
	// For resetting magnetometer
	writeRegister(SMPDIV, 19);

	// Get sample rate divider
	uint8_t sampleRtDiv = (1000 - sampleRate) - 1;

	// Set sample rate divider
	writeRegister(SMPDIV, sampleRtDiv);
}

void SimpleSPIClass::setGyroDrift()
{

	int count = 0;

	int interval = 1000;

	float avgXAngDrift = 0;
	float avgYAngDrift = 0;
	float avgZAngDrift = 0;

	while (count < interval)
	{

		readSensor();

		avgXAngDrift += (float)_gx / sampleRate;
		avgYAngDrift += (float)_gx / sampleRate;
		avgZAngDrift += (float)_gx / sampleRate;

		count++;

	}

	xAngDrift = avgXAngDrift / interval;
	yAngDrift = avgXAngDrift / interval;
	zAngDrift = avgXAngDrift / interval;

}


/* gets the MPU9250 WHO_AM_I register value, expected to be 0x71 */
int SimpleSPIClass::whoAmI() {
	// read the WHO AM I register
	if (readRegisters(WHO_AM_I, 1, buffer) < 0) {
		return -1;
	}
	// return the register value
	return buffer[0];
}

/* gets the AK8963 WHO_AM_I register value, expected to be 0x48 */
int SimpleSPIClass::whoAmIAK8963() {
	// read the WHO AM I register
	if (readAK8963Registers(AK8963_WHO_AM_I, 1, buffer) < 0) {
		return -1;
	}
	// return the register value
	return buffer[0];
}




// Write to register using SPI
int SimpleSPIClass::writeRegister(uint8_t subAddress, uint8_t data) {
	/* write data to device */
	beginTransaction(SPISettings(LS_CLOCK, MSBFIRST, SPI_MODE3)); // begin the transaction
	digitalWrite(SSPin, LOW); // select the MPU9250 chip
	transfer(subAddress); // write the register address
	transfer(data); // write the data
	digitalWrite(SSPin, HIGH); // deselect the MPU9250 chip
	endTransaction(); // end the transaction

	/* read back the register */
	readRegisters(subAddress, 1, buffer);
	/* check the read back register against the written register */
	if (buffer[0] == data) {
		return 1;
	}
	else {
		return -1;
	}
}


int SimpleSPIClass::readRegisters(uint8_t subAddress, uint8_t count, uint8_t* dest) {

	interruptMode = 0;

	// begin the transaction
	if (useSPIHS)
		beginTransaction(SPISettings(HS_CLOCK, MSBFIRST, SPI_MODE3));
	else
		beginTransaction(SPISettings(LS_CLOCK, MSBFIRST, SPI_MODE3));

	digitalWrite(SSPin, LOW); // select the MPU9250 chip
	transfer(subAddress | SPI_READ); // specify the starting register address
	for (uint8_t i = 0; i < count; i++) {
		dest[i] = transfer(0x00); // read the data
	}
	digitalWrite(SSPin, HIGH); // deselect the MPU9250 chip
	endTransaction(); // end the transaction

	return 1;

}


int SimpleI2CClass::writeByte(uint8_t address, uint8_t data) {


	txAddress = AK8963_I2C_ADDR;

	// reset tx buffer iterator vars
	txBufferIndex = 0;
	txBufferLength = 0;
	
	// in master transmitter mode
  // don't bother if buffer is full
	if (txBufferLength >= BUFFER_LENGTH) {
		return 0;
	}
	// put byte in tx buffer
	txBuffer[txBufferIndex] = address;
	++txBufferIndex;
	// update amount in buffer   
	txBufferLength = txBufferIndex;

	// don't bother if buffer is full
	if (txBufferLength >= BUFFER_LENGTH) {
		return 0;
	}
	// put byte in tx buffer
	txBuffer[txBufferIndex] = data;
	++txBufferIndex;
	// update amount in buffer   
	txBufferLength = txBufferIndex;

	// transmit buffer (blocking)
	uint8_t ret = twi_writeTo(txAddress, txBuffer, txBufferLength, 1, true);
	// reset tx buffer iterator vars
	txBufferIndex = 0;
	txBufferLength = 0;

	return ret;

}


/* writes a register to the AK8963 given a register address and data */
int SimpleSPIClass::writeAK8963Register(uint8_t subAddress, uint8_t data) {
	// set slave 0 to the AK8963 and set for write
	if (writeRegister(I2C_SLV0_ADDR, AK8963_I2C_ADDR) < 0) {
		return -1;
	}
	// set the register to the desired AK8963 sub address 
	if (writeRegister(I2C_SLV0_REG, subAddress) < 0) {
		return -2;
	}
	// store the data for write
	if (writeRegister(I2C_SLV0_DO, data) < 0) {
		return -3;
	}
	// enable I2C and send 1 byte
	if (writeRegister(I2C_SLV0_CTRL, I2C_SLV0_EN | (uint8_t)1) < 0) {
		return -4;
	}
	// read the register and confirm
	if (readAK8963Registers(subAddress, 1, buffer) < 0) {
		return -5;
	}
	if (buffer[0] == data) {
		return 1;
	}
	else {
		return -6;
	}
}

/* reads registers from the AK8963 */
int SimpleSPIClass::readAK8963Registers(uint8_t subAddress, uint8_t count, uint8_t* dest) {
	// set slave 0 to the AK8963 and set for read
	if (writeRegister(I2C_SLV0_ADDR, AK8963_I2C_ADDR | I2C_READ_FLAG) < 0) {
		return -1;
	}
	// set the register to the desired AK8963 sub address
	if (writeRegister(I2C_SLV0_REG, subAddress) < 0) {
		return -2;
	}
	// enable I2C and request the bytes
	if (writeRegister(I2C_SLV0_CTRL, I2C_SLV0_EN | count) < 0) {
		return -3;
	}
	delay(1); // takes some time for these registers to fill
  // read the bytes off the MPU9250 EXT_SENS_DATA registers
	int _status = readRegisters(EXT_SENS_DATA_00, count, dest);
	return _status;
}